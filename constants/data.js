const userData = {
  githubUsername: "ai-fanatic",
  name: "Naveen Chatlapalli",
  designation: "Agentic AI Architect",
  avatarUrl: "/avatar.png",
  email: "naveen@aifanatic.pro",
  phone: "1-999-999-9999",
  address: "Texas, USA",
  upcoming: [
    // Upcoming talks section is now hidden - events moved to recent highlights
  ],
  highlight: [
    {
      title: "Create Your First AI Agent with UiPath Agent Builder 🤖",
      link: "https://community.uipath.com/events/details/uipath-dallas-texas-presents-create-your-first-ai-agent-with-uipath-agent-builder/cohost-dallas-texas",
      imgUrl: "/AgentBuilder.png",
    },
    {
      title: "🤖 UiPath Clipboard AI: A TIME Magazine Best Invention of 2023 Unveiled 🌟",
      link: "https://community.uipath.com/events/details/uipath-dallas-texas-presents-uipath-clipboard-ai-a-time-magazine-best-invention-of-2023-unveiled",
      imgUrl: "/Mar.jpg",
    },
    {
      title: "Exploring UiPath Orchestrator API: Updates and Limits in 2024 🚀",
      link: "https://community.uipath.com/events/details/uipath-dallas-texas-presents-exploring-uipath-orchestrator-api-updates-and-limits-in-2024",
      imgUrl: "/Apr.jpg",
    },
    {
      title: "How to become an Agentic AI Architect",
      link: "https://www.youtube.com/watch?v=8_9e38kElHk",
      imgUrl: "/HowtobeSA.webp",
    },
    {
      title: "UiPath Integration Service",
      link: "https://www.youtube.com/watch?v=Lu5ooVPEBII&t=1330s",
      imgUrl: "/IntegrationService.webp",
    },
    // {
    //   title: "Exploring Language Model Evaluation",
    //   link: "https://www.youtube.com/watch?v=io8FlI-_gOo&ab_channel=LLMDaily",
    //   imgUrl: "/LLMDaily_2024.png",
    // },
    // {
    //   title: "Practical AI Podcast: Capabilities of LLMs",
    //   link: "https://changelog.com/practicalai/219",
    //   imgUrl: "/PracticalAI2023.png",
    // },
  ],
  about: {
    title1: "I help design automation solutions for enterprises.",
    title2:
      "I keep a side mission of simplifying topics about AI + AUTOMATION + HABITS + BOOKS.",
    currentPosition: "Agentic AI Architect at Ashling Partners",
    currentPositionUrl: "https://ashlingpartners.com",
  },
    bio: {
    description: [
      "I am Naveen Chatlapalli, an Agentic AI Architect, Gen AI Engineer, and tech writer based in Dallas, Texas. I design automation systems and AI-assisted workflows for enterprise teams.",
      "Education: M.S. in Computer Science from San Francisco Bay University, with undergraduate studies at Jawaharlal Nehru Technological University, Kakinada.",
      "Career: Started as a .NET developer, discovered UiPath, won a hackathon, and grew from RPA Developer to Lead RPA Developer to Agentic AI Architect at Ashling Partners.",
      "Community: 3-time UiPath MVP and Top Contributor (2024). I lead the UiPath Dallas Chapter, serve as VP of PR for Texas Dragon Toastmasters, and volunteer as a Telugu teacher at Silicon Andhra Manabadi.",
      "Recognition: Globally recognized multi-award judge (Globee Awards, TechX Awards finalist, HackSharks 2.0) and featured in Wired for coverage on AI agent liability.",
      "Solopreneurship: I build apps and products that make AI and automation accessible, with a focus on practical business outcomes.",
    ],
  },
  experience: [
    {
        title: "Agentic AI Architect",
        company: "Ashling Partners",
        year: "2020 - Present",
        companyLink: "https://ashlingpartners.com",
        desc: "Designing innovative solutions using Microsoft and UiPath for enterprise clients. Leading projects, mentoring developers, and supporting production deployments. Promoted from RPA Developer to Lead RPA Developer to Agentic AI Architect.",
    },
    {
        title: "Developer",
        company: "Process Weaver",
        year: "2016 - 2020",
        companyLink: "https://processweaver.com",
        desc: "Implemented logistics solutions involving FedEx, UPS, USPS packaging and hazmat handling for major organizations like Genentech, Disney, IMF, Applied Materials, and more.",
    },
    {
        title: "Computer Science Lab Assistant",
        company: "San Francisco Bay University",
        year: "2015 - 2016",
        companyLink: "https://sfbu.edu",
        desc: "Assisted students in learning SQL and Java programming, providing guidance on assignments and projects to enhance their understanding of core concepts.",
    },
    {
        title: "Software Developer",
        company: "Ben Franklin Opticians",
        year: "2012 - 2014",
        companyLink: "https://www.benfranklin.in/",
        desc: "Developed ERP systems, streamlining operations and enhancing business efficiency.",
    },
    {
        title: "Vice President of Public Relations",
        company: "Texas Dragon Toastmasters",
        year: "2025 - Present",
        companyLink: "https://texasdragon.org/",
        desc: "Promoting the club's activities and events, managing social media presence, and fostering community engagement.",
    },
    {
        title: "Telugu Teacher (Volunteer)",
        company: "Silicon Andhra Manabadi",
        year: "2024 - Present",
        companyLink: "https://manabadi.siliconandhra.org",
        desc: "Teaching kids the Telugu language and culture, preserving heritage, and fostering a love for learning.",
    },
    {
        title: "UiPath MVP",
        company: "UiPath",
        year: "2024 - Present",
        companyLink: "https://uipath.com",
        desc: "Recognized for contributions to the RPA community, thought leadership, and technical expertise in automation.",
    },
],

  resumeUrl: "/CVShah2023.pdf",
  SSRNUrl: "https://papers.ssrn.com/sol3/cf_dev/AbsByAuth.cfm?per_id=261155",
  GoogleSUrl: "https://scholar.google.com/citations?user=J6N60VcAAAAJ&hl=en",
  MediumUrl: "https://medium.com/@navaifanatic",
  BlogUrl: "http://projects.Naveenshah.com/blog/",
  socialLinks: {
    twitter: "https://twitter.com/navaifanatic",
    linkedin: "https://linkedin.com/in/nchatlapalli",
    github: "https://github.com/ai-fanatic",
    facebook: "https://facebook.com/",
    tiktok: "https://topmate.io/aifanatic",
    youtube: "https://www.youtube.com/@aifanatic",
    topmate: "https://topmate.io/aifanatic",
  },
  blogpost: [
    {
      title: "GPT-4 Loses: Data Labeling with LLMs",
      date: "Oct 2023",
      source: "LinkedIn",
      link: "https://www.linkedin.com/feed/update/urn:li:activity:7120746362236792832",
    },
    {
      title: "FinBERT beats GPT-4",
      date: "Sep 2023",
      source: "LinkedIn",
      link: "https://www.linkedin.com/feed/update/urn:li:activity:7108090020875444225",
    },
    {
      title: "Lessons earned from Bloomberg GPT",
      date: "Aug 2023",
      source: "LinkedIn",
      link: "https://www.linkedin.com/feed/update/urn:li:activity:7089609531961348096",
    },
    {
      title: "FinBERT beats GPT-3",
      date: "Feb 2023",
      source: "LinkedIn",
      link: "https://www.linkedin.com/feed/update/urn:li:activity:7024363501318000640",
    },
    {
      title: "Reasoning in Large Language Models",
      date: "Feb 2023",
      source: "Medium",
      link: "https://medium.com/@navaifanatic/reasoning-in-large-language-models-2ff33c318a94",
    },
    {
      title: "Data Science News Sources",
      date: "Dec 2022",
      source: "Medium",
      link: "https://medium.com/@navaifanatic/data-science-news-sources-71ad418242b4",
    },
    {
      title: "Accelerating Document AI",
      date: "Nov 2022",
      source: "Hugging Face",
      link: "https://huggingface.co/blog/document-ai",
    },
    {
      title:
        "Text style transfer in a spreadsheet using Hugging Face Inference Endpoints",
      date: "Nov 2022",
      source: "Medium",
      link: "https://medium.com/@navaifanatic/text-style-transfer-in-a-spreadsheet-using-hugging-face-inference-endpoints-cc55e4bd58b",
    },
    {
      title: "Few shot text classification with SetFit",
      date: "Oct 2022",
      source: "Medium",
      link: "https://medium.com/@navaifanatic/few-shot-text-classification-with-setfit-63ff7a02da5e",
    },
    {
      title: "Getting predictions intervals with conformal inference",
      date: "Sep 2022",
      source: "Medium",
      link: "https://medium.com/@navaifanatic/getting-predictions-intervals-with-conformal-inference-caff5be40eff",
    },
    {
      title: "Explaining predictions from 🤗 transformer models",
      date: "Aug 2022",
      source: "Medium",
      link: "https://medium.com/@navaifanatic/explaining-predictions-from-transformer-models-55ab9c6cab24",
    },
    {
      title: "Dynamic Adversarial Data Collection",
      date: "Aug 2022",
      source: "Medium",
      link: "https://medium.com/@navaifanatic/dynamic-adversarial-data-collection-712df9bac786",
    },
    {
      title: "Fine-Tuning for Image Classification using Transformers",
      date: "Aug 2022",
      source: "Medium",
      link: "https://medium.com/@navaifanatic/fine-tuning-for-image-classification-using-transformers-7ca01aeb7766",
    },
    {
      title:
        "The Art of Sprezzatura for Machine Learning: Building Interpretable Models",
      date: "Dec 2021",
      source: "Medium",
      link: "https://towardsdatascience.com/the-art-of-sprezzatura-for-machine-learning-e2494c0db727",
    },
    {
      title: "AI Use Cases for Cyber and Malware Analysts",
      date: "July 2021",
      source: "DataRobot",
      link: "https://www.datarobot.com/blog/ai-use-cases-for-cyber-and-malware-analysts/",
    },
    {
      title:
        "How MLOps Helps You Dodge The Wrecking Ball of Underspecification",
      date: "June 2021",
      source: "DataRobot",
      link: "https://www.datarobot.com/blog/how-mlops-helps-you-dodge-the-wrecking-ball-of-underspecification/",
    },
    {
      title: "Running Code and Failing Models",
      date: "Feb 2021",
      source: "DataRobot",
      link: "https://www.datarobot.com/blog/running-code-and-failing-models/",
    },
    {
      title:
        "Using Feature Importance Rank Ensembling (FIRE) for Advanced Feature Selection",
      date: "Jan 2021",
      source: "DataRobot",
      link: "https://www.datarobot.com/blog/using-feature-importance-rank-ensembling-fire-for-advanced-feature-selection/",
    },
    {
      title: "Predicting Music Genre Based on the Album Cover",
      date: "Aug 2020",
      source: "DataRobot",
      link: "https://www.datarobot.com/blog/predicting-music-genre-based-on-the-album-cover/",
    },
    {
      title: "Improving Model Management in Uncertain Times",
      date: "Jun 2020",
      source: "DataRobot",
      link: "https://www.datarobot.com/blog/improving-model-management-in-uncertain-times/",
    },
    {
      title: "Using Small Datasets to Build Models",
      date: "Apr 2020",
      source: "DataRobot",
      link: "https://www.datarobot.com/blog/using-small-datasets-to-build-models/",
    },
    {
      title: "AI in Turbulent Times: Navigating Changing Conditions Webinar",
      date: "Mar 2020",
      source: "DataRobot",
      link: "https://www.datarobot.com/blog/ai-in-turbulent-times-navigating-changing-conditions-webinar/",
    },
    {
      title:
        "Stand Up for Best Practices: Misuse of Deep Learning in Nature's Earthquake Aftershock Paper",
      date: "Jun 2019",
      source: "Medium",
      link: "https://towardsdatascience.com/stand-up-for-best-practices-8a8433d3e0e8",
    },
    {
      title: "Using Machine Learning to Peek Inside the Minds of NFL Coaches",
      date: "Jan 2019",
      source: "DataRobot",
      link: "https://www.datarobot.com/blog/using-machine-learning-to-peek-inside-the-minds-of-nfl-coaches/",
    },
    {
      title:
        "Taking Fantasy Football Analytics to the Next Level with Automated Machine Learning",
      date: "Sep 2018",
      source: "DataRobot",
      link: "https://www.datarobot.com/blog/taking-fantasy-football-analytics-to-the-next-level-with-automated-machine-learning/",
    },
    {
      title: "Optimization Strategies",
      date: "July 2018",
      source: "Medium",
      link: "https://medium.com/@navaifanatic/optimization-strategies-2fd23afe29f8",
    },
    {
      title:
        "Measure Once, Cut Twice: Moving Towards Iteration in Data Science",
      date: "Feb 2018",
      source: "DataRobot",
      link: "https://www.datarobot.com/blog/measure-once-cut-twice-moving-towards-iteration-in-data-science/s",
    },
    {
      title: "Using Unlabeled Data to Label Data",
      date: "Jan 2018",
      source: "Medium",
      link: "https://medium.com/@navaifanatic/using-unlabeled-data-to-label-data-8d8ee8e707ab",
    },
    {
      title: "Using Google's Quickdraw to create an MNIST style dataset!",
      date: "July 2017",
      source: "Medium",
      link: "https://medium.com/@navaifanatic/using-googles-quickdraw-to-create-an-mnist-style-dataset-709c0f99bc65",
    },
    {
      title: "Using xgbfi for revealing feature interactions",
      date: "Aug 2016",
      source: "Medium",
      link: "https://medium.com/@navaifanatic/using-xgbfi-for-revealing-feature-interactions-834cb3d33b02",
    },
    {
      title: "Outlier App",
      date: "Jun 2016",
      source: "Medium",
      link: "https://medium.com/@navaifanatic/outlier-app-ec01941f36a4",
    },
    {
      title: "SportVu Analysis",
      date: "Apr 2016",
      source: "Medium",
      link: "https://medium.com/@navaifanatic/sportvu-analysis-38cdf3e260e1",
    },
  ],
  video: [
    {
      title:
        "Evaluation for Large Language Models and Generative AI - A Deep Dive",
      date: "Nov 2023",
      source: "Youtube",
      link: "https://youtu.be/iQl03pQlYWY?si=kvQxuiYzUVDyIuCm",
    },
    {
      title:
        "NanoGPT using Simpsons Data: Get Started with Large Language Models",
      date: "Sep 2023",
      source: "Youtube",
      link: "https://youtu.be/Ty2_bR1mrBQ",
    },
    {
      title: "16 Challenges for LLMs - Paper Highlights",
      date: "Aug 2023",
      source: "Youtube",
      link: "https://youtu.be/B5MhLSapnms",
    },
    {
      title: "Llama 2 Paper Explained",
      date: "July 2023",
      source: "Youtube",
      link: "https://youtu.be/idmhH9_H1hY",
    },
    {
      title:
        "GPT or BERT? Reviewing the tradeoffs of using Large Language Models versus smaller models",
      date: "Jun 2023",
      source: "Youtube",
      link: "https://youtu.be/1Kaj5H_YARg",
    },
    {
      title:
        "Building Better Large Language Models - Key Concepts for Prompting and Fine Tuning",
      date: "Apr 2023",
      source: "Youtube",
      link: "https://youtu.be/NjtKcnLzo3g",
    },
    {
      title:
        "Efficient Large Language Model training with LoRA and Hugging Face PEFT",
      date: "Mar 2023",
      source: "Youtube",
      link: "https://youtu.be/YKCtbIJC3kQ",
    },
    {
      title:
        "Text style transfer in a spreadsheet using Hugging Face Inference Endpoints",
      date: "Nov 2022",
      source: "Youtube",
      link: "https://youtu.be/jA6VDKO7XfA",
    },
    {
      title: "SetFit: Few Shot Learning for Text Classification",
      date: "Oct 2022",
      source: "Youtube",
      link: "https://youtu.be/ZUK4zR0IeLU",
    },
    {
      title:
        "Prediction Intervals with Conformal Inference: An Intuitive Explanation",
      date: "Sep 2022",
      source: "Youtube",
      link: "https://youtu.be/ZUK4zR0IeLU",
    },
    {
      title: "LayoutLMv3 Training with CORD (receipts dataset)",
      date: "Sep 2022",
      source: "Youtube",
      link: "https://youtu.be/bsT_1uDRQVo",
    },
    {
      title: "Fine Tuning an Image Classifier on Indian Food Images",
      date: "Aug 2022",
      source: "Youtube",
      link: "https://youtu.be/j6WbCS0GLuY",
    },
    {
      title: "Explanation Approaches for Transformers",
      date: "Aug 2022",
      source: "Youtube",
      link: "https://youtu.be/ahgB8c_TgA8",
    },
  ],
    talks: [
    {
      title: "Employee onboarding automation",
      date: "",
      source: "YouTube",
      link: "https://www.youtube.com/watch?v=jZW7D4_OdLY",
    },
    {
      title: "Building AI Powered Applications with Azure Serverless Functions - Naveen Chatlapalli",
      date: "",
      source: "YouTube",
      link: "https://www.youtube.com/watch?v=I3AYEGNZzZk",
    },
    {
      title: "Building AI-Powered Applications with Azure Serverless Functions and C# .NET - Naveen Chatlapalli",
      date: "",
      source: "YouTube",
      link: "https://www.youtube.com/watch?v=rq4y7Jnelac",
    },
  ],
  solopreneurProjects: [
    {
      id: 1,
      name: "Unsloth",
      description: "Multimodal documentation agent that transforms raw assets into polished docs & FAQs",
      tech: "React + Azure Functions, OpenAI; 1st place Ashling Partners challenge",
      stage: "Live / evolving",
      category: "AI Documentation",
      difficulty: "Advanced",
      impact: "High",
      url: "unsloth.aifanatic.pro"
    },
    {
      id: 2,
      name: "Unsloth Chrome Extension",
      description: "One‑click capture & \"Generate‑Doc\" action that feeds Unsloth",
      tech: "Browser add‑on (companion)",
      stage: "MVP in build",
      category: "Browser Extension",
      difficulty: "Medium",
      impact: "Medium",
      url: "https://chromewebstore.google.com/category/extensions"
    },
    {
      id: 3,
      name: "TMGenie",
      description: "Toastmasters club manager—agendas, timing, attendance, history",
      tech: "React PWA",
      stage: "Live",
      category: "Management Tool",
      difficulty: "Medium",
      impact: "Medium",
      url: "tmgenie.aifanatic.pro"
    },
    {
      id: 4,
      name: "KaryAI",
      description: "AI‑task manager with smart estimates & Eisenhower analytics",
      tech: "Next.js, vector search; smartwatch fatigue agent incoming",
      stage: "Public beta",
      category: "Productivity",
      difficulty: "Advanced",
      impact: "High",
      url: "karyai.aiconic.one"
    },
    {
      id: 5,
      name: "AIconic",
      description: "Startup hub where anyone can spin up a project, track milestones, and turn ideas into shipped products—with AI workflow guidance baked‑in",
      tech: "Next.js front‑end, Firebase Auth, serverless orchestration, GPT \"coach\" for next‑step advice",
      stage: "MVP in build",
      category: "Startup Platform",
      difficulty: "Expert",
      impact: "Very High",
      url: "aiconic.one"
    },
    {
      id: 6,
      name: "AIconic Internship Platform",
      description: "Training platform for AIconic interns who will become AI engineers in the future—screen, onboard & monitor 12‑week intensive programs",
      tech: "Firebase Auth, GDrive video upload",
      stage: "MVP scaffolding",
      category: "Education",
      difficulty: "Advanced",
      impact: "High",
      url: "internships.aiconic.one"
    },
    {
      id: 7,
      name: "DivineRadio",
      description: "Continuous Hindu devotional radio with lyrics & translation, neatly sorted by deity for spiritual immersion",
      tech: "Lightweight React PWA",
      stage: "Live",
      category: "Entertainment",
      difficulty: "Easy",
      impact: "Medium",
      url: "divineradio.aifanatic.pro"
    },
    {
      id: 8,
      name: "Amrutham",
      description: "AI content generator for polished Telugu prose/poetry",
      tech: "NLP + LLM‑powered",
      stage: "Alpha",
      category: "Content Generation",
      difficulty: "Advanced",
      impact: "Medium",
      url: "amrutham.aiconic.one"
    },
    {
      id: 9,
      name: "LinkHub",
      description: "Smart link‑in‑bio with AI ordering & engagement analytics",
      tech: "Next.js, OpenAI, SQLite",
      stage: "Beta",
      category: "Social Media",
      difficulty: "Medium",
      impact: "Medium",
      url: "linkhub.aifanatic.pro"
    },
    {
      id: 10,
      name: "TeluguBadi",
      description: "Duolingo‑style Telugu learning with AI buddy & pronunciation scoring",
      tech: "React, spaced‑repetition engine, WebRTC audio",
      stage: "Alpha",
      category: "Education",
      difficulty: "Expert",
      impact: "High",
      url: "telugubadi.aiconic.one"
    },
    {
      id: 11,
      name: "Taste by Varun",
      description: "Premium Indian catering portal—AI menu builder & order flow",
      tech: "Next.js, Supabase, Stripe",
      stage: "Pilot use",
      category: "E-commerce",
      difficulty: "Advanced",
      impact: "Medium",
      url: "tastebyvarun.aiconic.one"
    },
    {
      id: 12,
      name: "AgentGate",
      description: "\"Amazon of AI agents\" marketplace—discover, deploy, pay‑per‑use",
      tech: "Serverless + billing plug‑ins",
      stage: "Prototype",
      category: "AI Marketplace",
      difficulty: "Expert",
      impact: "Very High",
      url: "agentgate.aifanatic.pro"
    },
    {
      id: 13,
      name: "Ideate",
      description: "Guided product‑ideation suite (problem → pitch deck)",
      tech: "React + GPT workflows",
      stage: "Beta",
      category: "Business Tools",
      difficulty: "Advanced",
      impact: "High",
      url: "ideate.aifanatic.pro"
    },
    {
      id: 14,
      name: "Gatherly",
      description: "AI RSVP manager with no‑show prediction & seating optimisation",
      tech: "Next.js, ML model, webhooks",
      stage: "Live",
      category: "Event Management",
      difficulty: "Advanced",
      impact: "Medium",
      url: "gatherly.aiconic.one"
    },
    {
      id: 15,
      name: "AgentSight",
      description: "Converts existing RPA workflows into AI agents in one click",
      tech: "UiPath API, LangChain, Azure Functions",
      stage: "Private alpha",
      category: "Enterprise AI",
      difficulty: "Expert",
      impact: "Very High",
      url: "agentsight.aifanatic.pro"
    },
    {
      id: 16,
      name: "TeluguMaatlaata",
      description: "Competitive Telugu word‑game platform for Silicon Andhra championships",
      tech: "React + Socket.IO real‑time play",
      stage: "Live (event‑based)",
      category: "Gaming",
      difficulty: "Advanced",
      impact: "Medium",
      url: "https://nextgen.telugumaatlaata.com/dashboard"
    },
    {
      id: 17,
      name: "Budjet",
      description: "Creative personal‑budget tracker that chats with your expenses & predicts cash flow",
      tech: "Next.js, Plaid API, LLM insights",
      stage: "Beta",
      category: "Finance",
      difficulty: "Advanced",
      impact: "High",
      url: "budjet.aifanatic.pro"
    },
    {
      id: 18,
      name: "RaiseTheFlag",
      description: "Early‑warning system to stop school drop‑outs; teachers flag & route to counselling",
      tech: "React, Firebase, analytics dashboard",
      stage: "Pilot with schools",
      category: "Social Impact",
      difficulty: "Advanced",
      impact: "Very High",
      url: "raisetheflag.aiconic.one"
    },
    {
      id: 19,
      name: "HomeCrafters",
      description: "AI CRM for an architecture firm—keeps clients updated on project progress",
      tech: "Next.js, image diff & 3‑D previews",
      stage: "Live (client‑specific)",
      category: "CRM",
      difficulty: "Expert",
      impact: "Medium",
      url: "homecrafters.aiconic.one"
    },
    {
      id: 20,
      name: "GC Genius",
      description: "Mentor platform guiding EB‑1A/O‑1 aspirants through profile‑building",
      tech: "GPT knowledge base, milestone tracker",
      stage: "Alpha",
      category: "Mentoring",
      difficulty: "Advanced",
      impact: "High",
      url: "gcgenius.aiconic.one"
    },
    {
      id: 21,
      name: "Flow Notes",
      description: "Speech to Text Conversion Chrome extension that adds notes easily to Notion with seamless workflow integration",
      tech: "Chrome Extension APIs, Web Speech API, Notion API",
      stage: "Live",
      category: "Browser Extension",
      difficulty: "Advanced",
      impact: "High",
      url: "https://chromewebstore.google.com/detail/flow-notes/njgmoefhpkekpkihdlghpjgofnojbfci"
    }
  ],
  blogs: [
    {
      slug: "multi-agent-orchestration-enterprise",
      title: "Multi-Agent Orchestration: The Architecture Behind Scalable Enterprise Automation",
      excerpt: "How to design, deploy, and manage multi-agent systems that handle complex enterprise workflows across departments without chaos.",
      date: "February 4, 2026",
      category: "Agentic AI Architecture",
      tags: ["MultiAgent", "Orchestration", "EnterpriseAI", "UiPath", "Architecture"],
      content: `
        <p class="lead">Last quarter, I architected a multi-agent system for a Fortune 500 financial services firm. Three agents—one for document extraction, one for compliance checking, and one for customer notifications—needed to coordinate on 10,000+ daily mortgage applications. The challenge wasn't building the agents. It was orchestrating them without creating a distributed nightmare.</p>

        <p>Single agents are easy. Multi-agent systems are where enterprise automation gets interesting—and dangerous. Get the architecture wrong, and you end up with agents talking past each other, duplicate work, race conditions, and a debugging hell that makes microservices look simple.</p>

        <p>Here's what I've learned building multi-agent orchestration systems that actually scale.</p>

        <hr>

        <h2>When You Actually Need Multiple Agents</h2>

        <p>Don't start with multi-agent. Start with one agent that uses good tools. Only graduate to multi-agent when you hit one of these walls:</p>

        <ul>
          <li><strong>Domain expertise boundaries:</strong> Your healthcare billing agent shouldn't also handle HIPAA compliance interpretation</li>
          <li><strong>Security isolation:</strong> The agent accessing customer PII shouldn't be the same one calling third-party APIs</li>
          <li><strong>Load patterns:</strong> One component needs 10x the compute of others</li>
          <li><strong>Team ownership:</strong> Different teams maintain different capabilities</li>
        </ul>

        <div class="warning-box">
          <strong>⚠️ The Trap:</strong> Teams often split agents prematurely because it "feels cleaner." Every agent boundary adds coordination overhead. Make sure the separation pays for itself.
        </div>

        <hr>

        <h2>The Three Orchestration Patterns That Work</h2>

        <h3>Pattern 1: Hub-and-Spoke (Centralized)</h3>

        <p>One orchestrator agent coordinates multiple specialized worker agents. The orchestrator understands the overall goal and delegates subtasks.</p>

        <h4>When to Use</h4>
        <ul>
          <li>Workflow has clear sequential dependencies</li>
          <li>You need centralized visibility and control</li>
          <li>Worker agents are truly stateless</li>
        </ul>

        <h4>Real Implementation: Claims Processing</h4>

        <pre><code>Orchestrator: "Process this auto insurance claim"
  ↓
Step 1: Delegate to DocumentAgent
        → Extract damage photos, police report, estimate
  ↓
Step 2: Delegate to FraudDetectionAgent  
        → Analyze patterns, flag anomalies
  ↓
Step 3: Delegate to PolicyAgent
        → Verify coverage, calculate payout
  ↓
Step 4: Delegate to NotificationAgent
        → Generate customer communication
  ↓
Orchestrator: Compile final decision package</code></pre>

        <div class="result-box">
          <strong>Latency:</strong> 12-15 seconds end-to-end | <strong>Success rate:</strong> 94% autonomous completion
        </div>

        <h3>Pattern 2: Pub/Sub (Event-Driven)</h3>

        <p>Agents communicate through an event bus. Each agent subscribes to relevant events and publishes results. No central coordinator.</p>

        <h4>When to Use</h4>
        <ul>
          <li>High throughput with loose coupling requirements</li>
          <li>Agents need to react to changes in real-time</li>
          <li>You want to add/remove agents without changing others</li>
        </ul>

        <h4>Real Implementation: Supply Chain Monitoring</h4>

        <pre><code>Event: "Shipment delayed at Port of Long Beach"
  ↓
InventoryAgent: Publishes "Stock risk: SKU-2847"
  ↓
SalesAgent: Subscribes → Publishes "Backorder notification needed"
  ↓
CustomerAgent: Subscribes → Generates proactive customer emails
  ↓
FinanceAgent: Subscribes → Updates revenue forecast</code></pre>

        <div class="insight-box">
          <strong>💡 Key Insight:</strong> Event-driven multi-agent systems scale better but are harder to debug. Invest in distributed tracing from day one.
        </div>

        <h3>Pattern 3: Federated (Hierarchical)</h3>

        <p>Multiple semi-autonomous agent groups, each with their own orchestrator, coordinated by a higher-level meta-orchestrator.</p>

        <h4>When to Use</h4>
        <ul>
          <li>Enterprise-wide automation spanning multiple departments</li>
          <li>Different teams own different agent clusters</li>
          <li>You need both autonomy and coordination</li>
        </ul>

        <h4>Real Implementation: Enterprise Onboarding</h4>

        <pre><code>Meta-Orchestrator: "Onboard new employee Sarah Chen"
  ↓
ITCluster:
  - Agent: Create accounts (AD, Slack, GitHub)
  - Agent: Provision laptop and peripherals
  - Agent: Set up VPN and security
  
HRCluster:
  - Agent: Enroll in benefits
  - Agent: Schedule orientation
  - Agent: Assign buddy/mentor
  
FacilitiesCluster:
  - Agent: Assign desk
  - Agent: Configure access badges
  - Agent: Order welcome kit</code></pre>

        <div class="result-box">
          <strong>Before:</strong> 47 manual tasks, 5 departments, 2+ weeks | <strong>After:</strong> 4 hours average, zero manual coordination
        </div>

        <hr>

        <h2>Critical Design Decisions</h2>

        <h3>1. Communication Protocol</h3>

        <p>Agents need a shared language. I use structured JSON with these fields:</p>

        <pre><code>{
  "message_id": "uuid",
  "correlation_id": "workflow-uuid",  // Ties all messages in a flow together
  "sender": "agent-name",
  "recipient": "agent-name|broadcast",
  "message_type": "request|response|event|error",
  "payload": { ... },
  "timestamp": "ISO8601",
  "ttl": 300  // Message expires after 5 minutes
}</code></pre>

        <div class="warning-box">
          <strong>⚠️ Don't:</strong> Let agents send free-form text to each other. You'll get "misunderstandings" that are impossible to debug.
        </div>

        <h3>2. State Management</h3>

        <p>Where does workflow state live?</p>

        <table>
          <tr>
            <th>Approach</th>
            <th>Best For</th>
            <th>Risk</th>
          </tr>
          <tr>
            <td>Orchestrator holds state</td>
            <td>Hub-and-spoke, short flows</td>
            <td>Orchestrator becomes bottleneck</td>
          </tr>
          <tr>
            <td>External state store (Redis)</td>
            <td>Long-running flows, high scale</td>
            <td>Complexity, consistency issues</td>
          </tr>
          <tr>
            <td>Event sourcing (log as state)</td>
            <td>Audit requirements, replay needs</td>
            <td>Storage costs, query complexity</td>
          </tr>
        </table>

        <p>For most enterprise scenarios, I use Redis with TTL and periodic checkpointing to a durable store.</p>

        <h3>3. Failure Handling</h3>

        <p>Multi-agent failures cascade. Design for it:</p>

        <ul>
          <li><strong>Timeouts:</strong> Every inter-agent call has a max wait (usually 30s)</li>
          <li><strong>Circuit breakers:</strong> After 3 failures, route around the failing agent</li>
          <li><strong>Compensating transactions:</strong> If Step 5 fails, undo Steps 1-4</li>
          <li><strong>Human escalation:</strong> Some failures need human judgment</li>
        </ul>

        <h4>Saga Pattern for Distributed Transactions</h4>

        <pre><code>Step 1: Reserve inventory
Step 2: Charge payment
Step 3: Create shipment

If Step 3 fails:
  → Compensate Step 2: Refund payment
  → Compensate Step 1: Release inventory
  → Escalate to human for investigation</code></pre>

        <hr>

        <h2>Monitoring Multi-Agent Systems</h2>

        <p>You need visibility at multiple levels:</p>

        <div class="metrics-grid">
          <div class="metric-card">
            <strong>Agent Level</strong>
            <ul>
              <li>Requests received/sent</li>
              <li>Average processing time</li>
              <li>Error rate by agent</li>
              <li>Token usage per agent</li>
            </ul>
          </div>
          <div class="metric-card">
            <strong>Workflow Level</strong>
            <ul>
              <li>End-to-end latency</li>
              <li>Completion rate</li>
              <li>Escalation rate</li>
              <li>Agent handoff count</li>
            </ul>
          </div>
          <div class="metric-card">
            <strong>System Level</strong>
            <ul>
              <li>Message queue depth</li>
              <li>State store latency</li>
              <li>Concurrent workflows</li>
              <li>Resource utilization</li>
            </ul>
          </div>
        </div>

        <div class="insight-box">
          <strong>💡 Essential:</strong> Distributed tracing. Every message should carry a trace ID. When something breaks at 2 AM, you need to reconstruct exactly which agent said what to whom.
        </div>

        <hr>

        <h2>UiPath-Specific Considerations</h2>

        <p>If you're building on UiPath, you have some powerful tools and some constraints:</p>

        <h3>Use UiPath Orchestrator for</h3>
        <ul>
          <li>Workflow scheduling and queuing</li>
          <li>Credential management (never hardcode in agents)</li>
          <li>Audit logging and compliance reporting</li>
          <li>Agent versioning and deployment</li>
        </ul>

        <h3>Use UiPath Apps + Agent Builder for</h3>
        <ul>
          <li>Human-in-the-loop interfaces</li>
          <li>Exception handling workflows</li>
          <li>Business user monitoring dashboards</li>
        </ul>

        <h3>Integration Pattern</h3>

        <pre><code>UiPath Agent (Agent Builder)
  ↓ Calls
Custom Orchestration Service (Azure Functions)
  ↓ Coordinates
Specialized Agents (Azure/OpenAI/Anthropic)
  ↓ Uses
UiPath Robots (for legacy system integration)
  ↓ Updates
Line-of-Business Systems (SAP, Salesforce, etc.)</code></pre>

        <hr>

        <h2>Anti-Patterns That Will Kill You</h2>

        <div class="antipattern">
          <h4>❌ The Chatty Agent</h4>
          <p>Agents that send 20 messages back and forth for a simple task. Every message boundary is latency and cost. Batch where possible.</p>
        </div>

        <div class="antipattern">
          <h4>❌ Distributed Monolith</h4>
          <p>Agents so tightly coupled they can't be deployed independently. If changing Agent A requires changing Agent B, you have a distributed monolith.</p>
        </div>

        <div class="antipattern">
          <h4>❌ Implicit Contracts</h4>
          <p>Agent A assumes Agent B returns data in a certain format. Use explicit schemas and validation.</p>
        </div>

        <div class="antipattern">
          <h4>❌ Infinite Loops</h4>
          <p>Agent A asks Agent B, which asks Agent A. Always include TTLs and cycle detection.</p>
        </div>

        <hr>

        <h2>Getting Started: The 4-Week Roadmap</h2>

        <h3>Week 1: Single Agent, Multiple Tools</h3>
        <p>Build one agent with excellent tool design. Master context management and error handling.</p>

        <h3>Week 2: Extract Specialized Capabilities</h3>
        <p>Identify one tool that's complex enough to become its own agent. Extract it. Implement hub-and-spoke.</p>

        <h3>Week 3: Add Real Orchestration</h3>
        <p>Implement proper state management, distributed tracing, and failure handling.</p>

        <h3>Week 4: Production Hardening</h3>
        <p>Load testing, security review, monitoring dashboards, runbooks.</p>

        <hr>

        <h2>Bottom Line</h2>

        <p>Multi-agent orchestration isn't about building cool AI systems—it's about solving real business problems that are too complex for single agents. The architecture matters. The coordination patterns matter. The monitoring and failure handling matter.</p>

        <p>The teams that succeed approach multi-agent systems the same way they'd approach any distributed system: with clear interfaces, explicit contracts, comprehensive testing, and ruthless operational discipline.</p>

        <p>Start simple. Add agents only when the complexity pays for itself. And never forget: the goal isn't to have multiple agents. The goal is to deliver business value reliably at scale.</p>

        <div class="final-cta">
          <strong>Build the simplest thing that works. Then make it simpler.</strong>
        </div>
      `
    },
    {
      slug: "agentic-automation-patient-scheduling",
      title: "Unlocking Smarter Healthcare: How Agentic Automation Transforms Patient Scheduling",
      excerpt: "A summary of my Ashling article on how agentic automation improves patient scheduling and access.",
      date: "February 4, 2026",
      category: "Healthcare Automation",
      tags: ["Healthcare", "AgenticAI", "Automation", "Scheduling"],
      content: `
        <p class="lead">This post is a brief summary of my Ashling article on how agentic automation can transform patient scheduling. For the full piece, read it on Ashling site.</p>
        
        <p><a href="https://ashling.ai/resources/unlocking-smarter-healthcare-how-agentic-automation-transforms-patient-scheduling" target="_blank" rel="noopener noreferrer">Read the full article on Ashling.</a></p>
        
        <h2>Why scheduling breaks</h2>
        <p>Manual handoffs, fragmented data, and high call volumes create delays, no-shows, and a poor patient experience.</p>
        
        <h2>What agentic automation changes</h2>
        <ul>
          <li>Understands intent across calls, chat, and forms</li>
          <li>Coordinates availability and rules in real time</li>
          <li>Escalates edge cases to humans with context</li>
        </ul>
        
        <h2>Outcome</h2>
        <div class="result-box">
          Faster scheduling, fewer errors, and a smoother patient journey.
        </div>
      `
    },
    {
      slug: "agent-patterns-that-work",
      title: "The 5 Agent Patterns That Actually Work in Production",
      excerpt: "What Anthropic learned from building agents with dozens of enterprise teams — and the composable patterns you can use today.",
      date: "February 4, 2026",
      category: "AI Engineering",
      tags: ["AgenticAI", "LLM", "ProductionML", "Anthropic"],
      content: `
        <p class="lead">I've spent the last year watching enterprise teams ship (and fail to ship) AI agents. The pattern is predictable: start with LangChain, hit a wall, rip it out, rebuild with raw APIs.</p>

        <p>Anthropic's recent engineering post validates what I've seen in the field. After working with dozens of teams building production agents, they identified <strong>five composable patterns</strong> that actually work. No frameworks. No magic. Just patterns.</p>

        <p>Here's what they found — with examples from my own implementations.</p>

        <hr>

        <h2>Pattern 1: Prompt Chaining</h2>
        
        <p class="pattern-subtitle">When the task decomposes cleanly into fixed steps</p>

        <p>Break a task into sequential LLM calls, where each step processes the output of the previous one. Add programmatic "gates" between steps to verify progress.</p>

        <h3>Real Example: Healthcare Compliance Generator</h3>
        
        <p>I built this for a healthcare client to generate compliance documents. The flow looks like this:</p>

        <ol>
          <li><strong>Step 1:</strong> Generate outline based on regulation type</li>
          <li><strong>Gate:</strong> Check outline covers all required sections</li>
          <li><strong>Step 2:</strong> Expand each section into draft content</li>
          <li><strong>Gate:</strong> Check word count and reading level</li>
          <li><strong>Step 3:</strong> Convert to final formatted document</li>
        </ol>

        <p>Each step is a separate LLM call. If a gate fails, we retry that step with feedback.</p>

        <div class="result-box">
          <strong>Results:</strong> 94% accuracy (vs. 67% with a single prompt) at ~8 seconds latency
        </div>

        <div class="warning-box">
          <strong>⚠️ The Trap:</strong> Don't chain just because you can. If steps aren't truly dependent, you're adding latency for no benefit.
        </div>

        <hr>

        <h2>Pattern 2: Routing</h2>
        
        <p class="pattern-subtitle">When inputs need different handling strategies</p>

        <p>A classifier routes inputs to specialized downstream handlers. This works well when you have clear input categories with different requirements.</p>

        <h3>Real Example: Customer Support Ticket Routing</h3>
        
        <p>Here's how we classified and routed tickets for a SaaS company:</p>

        <div class="example-flow">
          <div class="flow-item">
            <strong>"How do I reset my password?"</strong>
            <span>→ Claude Haiku (fast, cheap)</span>
          </div>
          <div class="flow-item">
            <strong>"My integration is returning 403s..."</strong>
            <span>→ Claude Sonnet + debugging tools</span>
          </div>
          <div class="flow-item">
            <strong>"I want a refund"</strong>
            <span>→ Human escalation</span>
          </div>
        </div>

        <div class="result-box">
          <strong>Impact:</strong> 60% of tickets now handled by Haiku at 1/10th the cost
        </div>

        <div class="insight-box">
          <strong>💡 Key Insight:</strong> Your router doesn't need to be perfect. A "confident" wrong route beats a hesitant correct one — you can always escalate.
        </div>

        <hr>

        <h2>Pattern 3: Parallelization</h2>
        
        <p class="pattern-subtitle">When you need speed or multiple perspectives</p>

        <p>Two variants:</p>

        <ul>
          <li><strong>Sectioning:</strong> Break into independent subtasks, run in parallel</li>
          <li><strong>Voting:</strong> Run same task multiple times, aggregate results</li>
        </ul>

        <h3>Example: Safety Guardrails (Sectioning)</h3>
        
        <p>I implemented this for a financial advice agent:</p>

        <pre><code>Parallel Call 1: Generate response to user query
Parallel Call 2: Screen for disallowed content

Both run simultaneously.
If Call 2 flags anything → block the response</code></pre>

        <div class="result-box">
          <strong>Latency increase:</strong> Only ~200ms
        </div>

        <h3>Example: Code Security Scanner (Voting)</h3>

        <pre><code>Run 1: Check for SQL injection (pattern A)
Run 2: Check for SQL injection (pattern B)  
Run 3: Check for SQL injection (pattern C)

Flag if 2+ runs agree</code></pre>

        <div class="result-box">
          <strong>Cost:</strong> 3x | <strong>Value:</strong> Prevents the one exploit that gets through
        </div>

        <div class="warning-box">
          <strong>⚠️ When NOT to use:</strong> Don't parallelize if subtasks aren't truly independent. Dependencies create coordination headaches.
        </div>

        <hr>

        <h2>Pattern 4: Orchestrator-Workers</h2>
        
        <p class="pattern-subtitle">When you can't predict the subtasks upfront</p>

        <p>A central "orchestrator" LLM dynamically breaks down tasks, delegates to worker LLMs, and synthesizes results. Workers aren't predefined — the orchestrator decides what's needed based on the specific input.</p>

        <h3>Real Example: Codebase Migration Tool</h3>
        
        <p>Needed to update Stripe API calls across 50+ files:</p>

        <pre><code>Orchestrator: "Update all Stripe API v1 calls to v2"
  ↓
Step 1: Scan repo, identify files with Stripe imports
  ↓
Step 2: For EACH file, delegate to worker:
        - Read file
        - Identify v1 patterns
        - Generate v2 replacement
        - Write changes
  ↓
Step 3: Verify all changes compile
Step 4: Run test suite</code></pre>

        <p>The orchestrator doesn't know upfront which files need changes. Workers discover and execute dynamically.</p>

        <div class="warning-box">
          <strong>⚠️ The Risk:</strong> This is the most complex pattern. Start with simpler approaches and graduate here only when you genuinely can't predict the workflow.
        </div>

        <hr>

        <h2>Pattern 5: Evaluator-Optimizer</h2>
        
        <p class="pattern-subtitle">When iterative refinement provides measurable value</p>

        <p>One LLM generates, another evaluates, in a loop. Continue until quality threshold met or max iterations reached.</p>

        <h3>Real Example: Marketing Copy Generation</h3>

        <pre><code>Loop (max 3 iterations):
  1. Generate: Write headline options
  2. Evaluate: Score on brand voice, clarity, CTA strength
  3. If score < 8/10:
       Provide feedback → regenerate
  4. Else: Done</code></pre>

        <p>The evaluator is explicit: <em>"This headline is too technical. Simplify for C-level audience."</em> The generator incorporates that feedback.</p>

        <div class="insight-box">
          <strong>💡 The Metric That Matters:</strong> If you can't define "better" quantitatively, this pattern won't help. You need evaluation criteria sharper than "make it good."
        </div>

        <hr>

        <h2>The Meta-Pattern: Start Simple</h2>

        <p>Anthropic's core advice (and mine):</p>

        <ol>
          <li>Begin with a single LLM call</li>
          <li>Add retrieval</li>
          <li>Add in-context examples</li>
          <li>Only when that fails, add one of these patterns</li>
          <li>Only when that fails, consider full agents</li>
        </ol>

        <h3>Instrument Everything</h3>

        <p>You can't improve what you don't measure. Every pattern should track:</p>

        <ul>
          <li>Latency (p50, p95, p99)</li>
          <li>Success/failure rates by step</li>
          <li>Cost per task</li>
          <li>Human validation samples</li>
        </ul>

        <hr>

        <h2>Frameworks: Use With Eyes Open</h2>

        <p>LangChain, CrewAI, LlamaIndex — they make demos fast. But successful production teams often <strong>reduce</strong> abstraction, not add it.</p>

        <div class="insight-box">
          <strong>💡 My Rule:</strong> Use a framework for the 20% of boilerplate it handles well (tool calling, retries, parsing). Build the 80% that's unique to your problem yourself. You'll debug faster and understand your system.
        </div>

        <hr>

        <h2>Bottom Line</h2>

        <p>Agents aren't magic. They're software with more moving parts. These five patterns are composable building blocks — mix, match, customize for your use case.</p>

        <p>The teams shipping production agents aren't the ones with the fanciest architectures. They're the ones that <strong>measure, iterate, and resist complexity until it's justified.</strong></p>
      `
    },
    {
      slug: "uipath-agents-best-practices",
      title: "UiPath Agents Best Practices: A Complete Guide",
      excerpt: "Lessons from shipping enterprise-grade AI agents at scale with UiPath Agents.",
      date: "February 4, 2026",
      category: "RPA & Automation",
      tags: ["UiPath", "AgenticAI", "RPA", "EnterpriseAutomation"],
      content: `
        <p class="lead">I've spent the last 18 months building UiPath Agents for enterprise clients — from quick POCs to production systems handling thousands of daily interactions. Along the way, I've learned what works, what breaks, and what separates demo-worthy experiments from systems that actually deliver business value.</p>

        <p>UiPath Agents represent a significant shift in how we think about automation. Unlike traditional RPA bots that follow rigid, pre-defined workflows, Agents leverage large language models to understand context, make decisions, and take actions dynamically.</p>

        <hr>

        <h2>1. Design Your Agent's "Personality" Deliberately</h2>

        <p>Your Agent isn't just a tool — it's a digital employee representing your brand. Define clear behavioral guidelines:</p>

        <ul>
          <li>How formal or casual should the Agent be?</li>
          <li>Should it apologize when it makes mistakes, or simply correct them?</li>
          <li>What tone is appropriate for your industry?</li>
        </ul>

        <p>I document this in a "Persona Specification" alongside technical docs. For a healthcare client: <em>"Professional but warm. Never make medical claims. Always defer to human providers for clinical decisions."</em></p>

        <hr>

        <h2>2. Master the Context Window</h2>

        <p>Context isn't free — every token costs latency and money. The art is providing exactly what the Agent needs, nothing more.</p>

        <h3>Best Practices</h3>

        <ul>
          <li><strong>Full context:</strong> Last 5 conversation turns</li>
          <li><strong>Summarized context:</strong> Earlier conversation history</li>
          <li><strong>Extracted facts:</strong> Key information stored separately</li>
        </ul>

        <div class="result-box">
          <strong>Real-world impact:</strong> One client's Agent consumed 8,000 tokens per request. After optimizing: 2,500 tokens — <strong>cutting costs by 70%</strong> and improving response times by 40%.
        </div>

        <hr>

        <h2>3. Build Robust Tool Design</h2>

        <p>Tools are how your Agent interacts with the world. Poorly designed tools are the <strong>#1 source of Agent failures</strong> in production.</p>

        <h3>Naming Conventions</h3>

        <p>Prefer descriptive names:</p>

        <div class="comparison">
          <div class="bad">❌ <code>query_database_table_orders</code></div>
          <div class="good">✅ <code>get_customer_order_history</code></div>
        </div>

        <h3>Error Handling</h3>

        <p>Every tool call can fail. Build retry logic and graceful degradation:</p>

        <pre><code>try:
    result = create_ticket(user_id, description)
    return {
        "success": True, 
        "ticket_id": result.id
    }
except InsufficientPermissionsError:
    return {
        "success": False, 
        "error": "I don't have permission to create tickets for your account type."
    }
except RateLimitError:
    return {
        "success": False, 
        "error": "I'm experiencing high traffic right now. Please try again in a moment."
    }</code></pre>

        <div class="insight-box">
          <strong>💡 Pro Tip:</strong> Always return structured responses. Never return raw exceptions to the LLM.
        </div>

        <hr>

        <h2>4. Implement Human-in-the-Loop Smartly</h2>

        <p>The goal is strategic human involvement — only when necessary, but always when critical.</p>

        <h3>Escalation Criteria</h3>

        <ul>
          <li>✅ High-stakes decisions (cancellations, refunds over $X)</li>
          <li>✅ Situations requiring empathy</li>
          <li>✅ Edge cases the Agent hasn't been trained on</li>
          <li>✅ User explicitly requests a human</li>
        </ul>

        <h3>The Escalation Flow</h3>

        <p>When escalating, the Agent should:</p>

        <ol>
          <li>Acknowledge the handoff</li>
          <li>Summarize the conversation</li>
          <li>Transfer context</li>
          <li>Set appropriate expectations</li>
        </ol>

        <hr>

        <h2>5. Monitor, Measure, Iterate</h2>

        <p>Track the right metrics:</p>

        <div class="metrics-grid">
          <div class="metric-card">
            <strong>Operational</strong>
            <ul>
              <li>Response time (p50, p95, p99)</li>
              <li>Token usage</li>
              <li>Error rates</li>
              <li>Escalation rate</li>
            </ul>
          </div>
          <div class="metric-card">
            <strong>Quality</strong>
            <ul>
              <li>CSAT/NPS</li>
              <li>Task completion rate</li>
              <li>First-contact resolution</li>
            </ul>
          </div>
        </div>

        <div class="result-box">
          <strong>Real-world example:</strong> We noticed a 15% drop in task completion for "password reset" requests. Investigation revealed the Agent was too verbose — users abandoned before getting to the reset link. Streamlined response, completion rates recovered.
        </div>

        <hr>

        <h2>Common Anti-Patterns to Avoid</h2>

        <div class="antipattern">
          <h4>❌ The "Omniscient" Agent</h4>
          <p>Trying to build one Agent that does everything.</p>
          <p><strong>Better:</strong> Specialized Agents with a router.</p>
        </div>

        <div class="antipattern">
          <h4>❌ Prompt Engineering Over-Reliance</h4>
          <p>Spending weeks tweaking prompts instead of fixing architecture.</p>
          <p><strong>Better:</strong> Invest in tool design and evaluation frameworks.</p>
        </div>

        <div class="antipattern">
          <h4>❌ Ignoring Latency</h4>
          <p>Accepting 10+ second response times.</p>
          <p><strong>Better:</strong> Optimize context, implement streaming.</p>
        </div>

        <div class="antipattern">
          <h4>❌ Neglecting Maintenance</h4>
          <p>Deploying the Agent and moving on.</p>
          <p><strong>Better:</strong> Schedule regular reviews, monitor drift.</p>
        </div>

        <hr>

        <h2>Bottom Line</h2>

        <p>Building production-ready UiPath Agents is as much about operational discipline as technical implementation. The teams that succeed treat Agents as <strong>products, not experiments</strong> — with clear requirements, robust testing, continuous monitoring, and ongoing refinement.</p>

        <p>The best Agents I've built weren't the ones with the most sophisticated prompts. They were the ones that solved real problems reliably, learned from their mistakes, and earned user trust through consistent, helpful interactions.</p>

        <div class="final-cta">
          <strong>Start simple. Measure everything. Iterate relentlessly.</strong>
        </div>
      `
    }
  ]
};

export default userData;


